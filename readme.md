## 1.  개요

MySQL BY 8.0.42 ver.

`접속 #1 : docker exec -it data-modeling-mysql bash`

`접속 #2 : mysql -u root -p`

- 본 프로젝트는 Data-modeling 등 Data 설계 및 아키텍칭에 대한 내용을 담고 있으며, 개발과 더불어 Database에 대한 내용들을 기록한다.
- 일전과 마찬가지로 이론에 그치지 않고 실무 활용, 이와 관련한 깊이 있는 고민을 통해 즉각 실무 적용이 가능할 정도로 역량을 보완하도록 한다.

구체적인 내용은 벨로그 통해 기술, 기술적인 내용들은 아래 내용으로 간략하게 기재.

## 2. 데이터 표현의 근간 - JOIN

데이터 모델링은 효율적인 데이터 관리를 위해 필요한 분리적 과정이며,</br>
JOIN은 이러한 데이터 모델링에 의해 분리된 데이터를 의미있는 표현으로 만들기 위해 하는 통합의 과정이다.

논리적 처리 순서
- FROM/JOIN > WHERE > SELECT

쿼리 최적화 순서
- WHERE > FROM/JOIN > SELECT

둘의 순서는 다를 수 있지만 결과는 반드시 동일하다.

그 종류는 내부조인(INNER JOIN), 외부조인(OUTER JOIN)이 존재한다.

> 조인을 할 때 중요한 점은 기준이 되는 테이블을 잘 선정하여 행의 개수가 늘어나지 않도록 조절하는 것.
- 반드시 자식(FK)에서 부모(PK)를 참조하는 방향으로 참고해야 데이터 행의 개수가 늘어나지 않는다.
  - 다른 쪽 테이블에는 PK는 유일한 인자이므로 1:1 매핑을 보장할 수 있기 때문이다.
- 반대로 부모(PK) 측에서 자식(FK) 측으로 참조하는 방향일 경우 데이터 행의 개수가 늘어날 수 있다.

### 2-1. INNER JOIN

존재와 일치를 모두 만족하는 데이터를 표현하기 위한 방법으로, 교집합의 개념이다.
</br>
JOIN의 방향은 어디든 결과가 동일하지만, 가독성을 위해 기준 테이블을 명확히 구성하는 것이 좋다.
</br>
ALIAS의 사용을 생활화하는 것이 좋다(Column -> 사용, Table -> 생략).


### 2-2. OUTER JOIN

기준 테이블의 존재를 만족하는 데이터를 표현하기 위한 방법으로, 합집합의 개념이다.
</br>
두 도메인 중 하나의 도메인에만 데이터가 존재하는 경우도 집계가 필요할 경우 사용한다.

- 기준이 되는 테이블을 피벗으로 사용하여 OUTER JOIN - LEFT OUTER JOIN
- 기준이 되는 테이블 반대편을 피벗으로 사용하여 OUTER JOIN - RIGHT OUTER JOIN

### 2-3. CROSS JOIN

교집합과 양쪽의 OUTER 영역까지 모두 표현한다.

### 2-4. SELF JOIN

말 그대로 본인이 본인을 참조하는 경우이다.
</br>
내부 데이터가 상하관계, 계층관계에 있다면 굳이 번거롭게 별도 테이블을 운용할 필요없이 SELF JOIN으로 계층적 구조를 표현가능하다.
- 조직도, 부서구성도(보통은 LEVEL을 사용하지만 테이블 안의 테이블을 참조하는 구조로 CROSS JOIN도 유용한 방안이 될 수 있음)

### 2-5. CROSS JOIN

두 테이블에서 가능한 모든 조합에 대한 데이터를 생성한다(=CARTESIAN Product).
</br>
가능한 모든 조합의 경우를 나타내므로, ON과 같은 특정 연결조건을 사용하지 않는다.

기본 데이터를 만들고자 할 경우, 가능한 모든 경우의 수에 대한 bulk insert를 진행한다면 유용한 방안이 될 수 있음.

## 3. 서브쿼리

내부적으로 SELECT를 통해 데이터를 조회하는 쿼리가 들어있는 경우.
</br>
괄호안의 서브쿼리를 먼저 실행하여 메인쿼리가 해당 결과를 그대로 활용한다.

- 단일 서브쿼리
  - 단일 값, 값 추출 후 비교 및 할당 등을 한다면 단일 행(스칼라) 서브쿼리
    - =, <, >
  - 다중 값에 대한 리스트(목록)을 추출하여 조건으로 활용한다면 다중 행 서브쿼리
    - IN, ANY, ALL
  - 다중 컬럼을 비교할 경우
    - 여러 컬럼 값을 1:1 비교, 다중 컬럼 단일 행 서브 쿼리
      - WHERE (c1, c2) = (SELECT C1, C2 FROM ~~)
    - 여러 컬럼의 조합(리스트) 비교, 다중 컬럼 다중 행 서브 쿼리
      - WHERE (c1, c2) IN (SELECT C1, C2 FROM ~~)
- 다중 서브쿼리(상관 서브쿼리)
  - 메인쿼리의 특정 값을 서브쿼리에 사용하여 정보를 처리해야 하는 경우
  - 메인쿼리의 특정 값을 서브쿼리에 상관하고 연관관계를 맺어야 하는 경우(서브쿼리 독립적 실행 불가)
    - 메인쿼리에서 필요한 값의 개수만큼 서브쿼리를 실행 필요할 수 있음
- 가상의 테이블을 생성하는 경우(Inline View)
  - 가상의 테이블을 만든다, 파생 테이블 혹은 인라인으로 테이블을 생성한다, 테이블 쿼리

> cf. EXISTS / NOT EXISTS

- 서브쿼리로 추출한 데이터 혹은 기준 테이블의 규모가 클 경우 IN/ANY/ALL과 같은 다중 행/컬럼 서브쿼리는 성능 하락의 원인이 될 수 있다.
- 이를 보완하기 위한 방안이 EXISTS, 서브쿼리가 반환하는 결과와 "비교"가 아닌, 서브쿼리가 결과를 반환하는지에 대한 "여부 확인"이다.
  - 메인 쿼리를 읽고, 해당 결과(1 row)를 바탕으로 EXISTS의 서브쿼리 TRUE/FALSE 여부를 확인
  - 하나라도 존재한다면 메인쿼리의 해당 결과(1 row)를 출력한다.
- 그 반대의 결과가 NOT EXISTS

대부분의 상관 쿼리는 직관적이지만, 메인 쿼리를 먼저 실행하기에 기준 데이터 개수가 많아지면 성능이 그만큼 하락한다.
</br>
만약 성능을 개선하고 싶다면 상관 서브쿼리대신 JOIN 등을 사용하며, EXISTS를 사용할 경우 성능이 더 개선될 수 있는 여지가 있다.

## 4. JOIN vs 서브쿼리 = 성능 vs 가독성

> 일반적으로 JOIN이 서브쿼리보다 성능이 좀 더 좋다.
- 쿼리 옵티마이저가 구성하는 실행 계획에 대한 힌트를 JOIN에서 더 많이 얻을 수 있기 때문이다.
- 또한 서브쿼리의 경우 서브쿼리의 결과를 메모리에 위에 올려두고 이를 참조하는 방식으로 진행하기에, 동작이 비효율적인 경우가 많다.
- 그러나 논리적 읽기 단위, 덩어리를 명확하게 구분해주는 서브쿼리의 특성상 가독성 측면에서는 더 좋을 수 있다.

> Proposal
- JOIN 및 WHERE 등 성능우선적으로 고려
- 서브쿼리를 사용해도 무방하다면 서브쿼리를 사용하며, 그 목적에 맞게 가독성 측면을 고려
- 서브쿼리 사용 시 EXISTS를 활용하여 성능 개선점을 확보한다.

## 5. UNION / UNION ALL

JOIN이 여러 테이블들을 수평적으로 붙이고 확장하여 다수의 컬럼들을 MERGE하는 과정이라면,
</br>
UNION은 다양한 결과집합을 수직적으로 합쳐서 하나의 집합으로 만드는 과정이며, 중복된 데이터는 마지막에 단일화한다.
</br>
UNION ALL은 결과 집합을 중복제거 없이 그대로 수직적으로 붙이는 과정이다.

핵심 포인트는, "도메인은 같지만 연관성이 없는 데이터들을 하나의 결과집합으로 모을때"

UNION/UNION ALL 적용 후 결과정렬은 가장 마지막에 한번만 적용 가능하다.

