## 1.  개요

MySQL BY 8.0.42 ver.

`접속 #1 : docker exec -it data-modeling-mysql bash`

`접속 #2 : mysql -u root -p`

- 본 프로젝트는 Data-modeling 등 Data 설계 및 아키텍칭에 대한 내용을 담고 있으며, 개발과 더불어 Database에 대한 내용들을 기록한다.
- 일전과 마찬가지로 이론에 그치지 않고 실무 활용, 이와 관련한 깊이 있는 고민을 통해 즉각 실무 적용이 가능할 정도로 역량을 보완하도록 한다.

구체적인 내용은 벨로그 통해 기술, 기술적인 내용들은 아래 내용으로 간략하게 기재.

## 2. 데이터 표현의 근간 - JOIN

데이터 모델링은 효율적인 데이터 관리를 위해 필요한 분리적 과정이며,</br>
JOIN은 이러한 데이터 모델링에 의해 분리된 데이터를 의미있는 표현으로 만들기 위해 하는 통합의 과정이다.

논리적 처리 순서
- FROM/JOIN > WHERE > SELECT

쿼리 최적화 순서
- WHERE > FROM/JOIN > SELECT

둘의 순서는 다를 수 있지만 결과는 반드시 동일하다.

그 종류는 내부조인(INNER JOIN), 외부조인(OUTER JOIN)이 존재한다.

> 조인을 할 때 중요한 점은 기준이 되는 테이블을 잘 선정하여 행의 개수가 늘어나지 않도록 조절하는 것.
- 반드시 자식(FK)에서 부모(PK)를 참조하는 방향으로 참고해야 데이터 행의 개수가 늘어나지 않는다.
  - 다른 쪽 테이블에는 PK는 유일한 인자이므로 1:1 매핑을 보장할 수 있기 때문이다.
- 반대로 부모(PK) 측에서 자식(FK) 측으로 참조하는 방향일 경우 데이터 행의 개수가 늘어날 수 있다.

### 2-1. INNER JOIN

존재와 일치를 모두 만족하는 데이터를 표현하기 위한 방법으로, 교집합의 개념이다.
</br>
JOIN의 방향은 어디든 결과가 동일하지만, 가독성을 위해 기준 테이블을 명확히 구성하는 것이 좋다.
</br>
ALIAS의 사용을 생활화하는 것이 좋다(Column -> 사용, Table -> 생략).


### 2-2. OUTER JOIN

기준 테이블의 존재를 만족하는 데이터를 표현하기 위한 방법으로, 합집합의 개념이다.
</br>
두 도메인 중 하나의 도메인에만 데이터가 존재하는 경우도 집계가 필요할 경우 사용한다.

- 기준이 되는 테이블을 피벗으로 사용하여 OUTER JOIN - LEFT OUTER JOIN
- 기준이 되는 테이블 반대편을 피벗으로 사용하여 OUTER JOIN - RIGHT OUTER JOIN

### 2-3. CROSS JOIN

교집합과 양쪽의 OUTER 영역까지 모두 표현한다.

### 2-4. SELF JOIN

말 그대로 본인이 본인을 참조하는 경우이다.
</br>
내부 데이터가 상하관계, 계층관계에 있다면 굳이 번거롭게 별도 테이블을 운용할 필요없이 SELF JOIN으로 계층적 구조를 표현가능하다.
- 조직도, 부서구성도(보통은 LEVEL을 사용하지만 테이블 안의 테이블을 참조하는 구조로 CROSS JOIN도 유용한 방안이 될 수 있음)

### 2-5. CROSS JOIN

두 테이블에서 가능한 모든 조합에 대한 데이터를 생성한다(=CARTESIAN Product).
</br>
가능한 모든 조합의 경우를 나타내므로, ON과 같은 특정 연결조건을 사용하지 않는다.

기본 데이터를 만들고자 할 경우, 가능한 모든 경우의 수에 대한 bulk insert를 진행한다면 유용한 방안이 될 수 있음.

## 3. 서브쿼리

내부적으로 SELECT를 통해 데이터를 조회하는 쿼리가 들어있는 경우.
</br>
괄호안의 서브쿼리를 먼저 실행하여 메인쿼리가 해당 결과를 그대로 활용한다.

- 단일 서브쿼리
  - 단일 값, 값 추출 후 비교 및 할당 등을 한다면 단일 행(스칼라) 서브쿼리
    - =, <, >
  - 다중 값에 대한 리스트(목록)을 추출하여 조건으로 활용한다면 다중 행 서브쿼리
    - IN, ANY, ALL
  - 다중 컬럼을 비교할 경우
    - 여러 컬럼 값을 1:1 비교, 다중 컬럼 단일 행 서브 쿼리
      - WHERE (c1, c2) = (SELECT C1, C2 FROM ~~)
    - 여러 컬럼의 조합(리스트) 비교, 다중 컬럼 다중 행 서브 쿼리
      - WHERE (c1, c2) IN (SELECT C1, C2 FROM ~~)
- 다중 서브쿼리(상관 서브쿼리)
  - 메인쿼리의 특정 값을 서브쿼리에 사용하여 정보를 처리해야 하는 경우
  - 메인쿼리의 특정 값을 서브쿼리에 상관하고 연관관계를 맺어야 하는 경우(서브쿼리 독립적 실행 불가)
    - 메인쿼리에서 필요한 값의 개수만큼 서브쿼리를 실행 필요할 수 있음
- 가상의 테이블을 생성하는 경우(Inline View)
  - 가상의 테이블을 만든다, 파생 테이블 혹은 인라인으로 테이블을 생성한다, 테이블 쿼리

> cf. EXISTS / NOT EXISTS

- 서브쿼리로 추출한 데이터 혹은 기준 테이블의 규모가 클 경우 IN/ANY/ALL과 같은 다중 행/컬럼 서브쿼리는 성능 하락의 원인이 될 수 있다.
- 이를 보완하기 위한 방안이 EXISTS, 서브쿼리가 반환하는 결과와 "비교"가 아닌, 서브쿼리가 결과를 반환하는지에 대한 "여부 확인"이다.
  - 메인 쿼리를 읽고, 해당 결과(1 row)를 바탕으로 EXISTS의 서브쿼리 TRUE/FALSE 여부를 확인
  - 하나라도 존재한다면 메인쿼리의 해당 결과(1 row)를 출력한다.
- 그 반대의 결과가 NOT EXISTS

대부분의 상관 쿼리는 직관적이지만, 메인 쿼리를 먼저 실행하기에 기준 데이터 개수가 많아지면 성능이 그만큼 하락한다.
</br>
만약 성능을 개선하고 싶다면 상관 서브쿼리대신 JOIN 등을 사용하며, EXISTS를 사용할 경우 성능이 더 개선될 수 있는 여지가 있다.

## 4. JOIN vs 서브쿼리 = 성능 vs 가독성

> 일반적으로 JOIN이 서브쿼리보다 성능이 좀 더 좋다.
- 쿼리 옵티마이저가 구성하는 실행 계획에 대한 힌트를 JOIN에서 더 많이 얻을 수 있기 때문이다.
- 또한 서브쿼리의 경우 서브쿼리의 결과를 메모리에 위에 올려두고 이를 참조하는 방식으로 진행하기에, 동작이 비효율적인 경우가 많다.
- 그러나 논리적 읽기 단위, 덩어리를 명확하게 구분해주는 서브쿼리의 특성상 가독성 측면에서는 더 좋을 수 있다.

> Proposal
- JOIN 및 WHERE 등 성능우선적으로 고려
- 서브쿼리를 사용해도 무방하다면 서브쿼리를 사용하며, 그 목적에 맞게 가독성 측면을 고려
- 서브쿼리 사용 시 EXISTS를 활용하여 성능 개선점을 확보한다.

## 5. UNION / UNION ALL

JOIN이 여러 테이블들을 수평적으로 붙이고 확장하여 다수의 컬럼들을 MERGE하는 과정이라면,
</br>
UNION은 다양한 결과집합을 수직적으로 합쳐서 하나의 집합으로 만드는 과정이며, 중복된 데이터는 마지막에 단일화한다.
</br>
UNION ALL은 결과 집합을 중복제거 없이 그대로 수직적으로 붙이는 과정이다.

핵심 포인트는, "도메인은 같지만 연관성이 없는 데이터들을 하나의 결과집합으로 모을때"
</br>
다만, UNION ALL 과정에 중복제거 과정이 더해지는 것이 UNION이므로, 성능적으로는 오히려 UNION ALL이 더 유리할 수 있다.

UNION/UNION ALL 적용 후 결과정렬은 가장 마지막에 한번만 적용 가능하다.

## 6. CASE

데이터를 동적으로 가공하거나 새로운 의미를 부여하고자 할 때 사용하는 분기처리 구문이다.
- COLUMN CASE WHEN "특정 문자열"/THEN...ELSE END - Simple Case
- COLUMN CASE WHEN "동등 혹은 비교 조건"/THEN...ELSE END - Searched Case

CASE는 기준에 따른 분류와 집계를 할때 그 빛을 발한다.
- CASE에 따른 분류
  - order by를 통해 case에 따른 분류 우선순위를 지정해줄 수도 있다.
  - 다중 집계 시 사용가능(CASE/GROUP BY 혼용)
- CASE에 따른 GROUP BY 및 집계

## 7. VIEW

쿼리가 길고 복잡하지만 다양한 사람들이 공통적으로 사용해야 하는 경우, 쿼리를 어딘가에 저장해두고 사용하고자 한다.

> 쿼리 결과를 가상의 테이블 및 데이터로 추상화하여, 복잡한 쿼리를 단순화하고 재활용하여 사용하기 위한 개념이다.
- 뷰는 데이터가 아닌, 데이터를 추출하는 쿼리로 데이터 추출 시점마다 원본 데이터를 조회하므로 최신 데이터를 보장할 수 있다.
- 다양한 사람들에게 불필요한 접근 권한을 부여하지 않고, 뷰를 통한 제한된 접근만 허용이 가능하다.
- 원본 데이터의 구조 및 변경점이 발생하더라도, 뷰 사용 시 뷰를 수정하면 되는 수정용이성(논리적 독립성)을 확보할 수 있다.

이러한 유지보수성 및 보안의 이면에는 성능/구조적 단점이 존재한다.
- view 안에 view(nested views) 등 너무 복잡한 구조일 경우 옵티마이저가 최적의 실행 계획을 찾는데 방해가 될 수 있다.
- view는 오로지 가상의 테이블, 가상의 데이터로만 간주해야 하며 조회용도로만 사용해야 한다.
  - view 데이터를 변경하고 이에 따른 폭포(cascade)를 원본 데이터까지 이어지게 하려면 데이터 반영 규칙 등 명확한 기준이 필요하다.

## 8. INDEX

아무런 힌트없이 모든 데이터를 일일이 탐색하고 찾는 FULL TABLE SCAN 발생
- DB사양(CPU/디스크 I/O)에 따라 다르지만 보통 1000만건 기준 수초 ~ 1분이상 소요된다.
- 기업용 서버 환경인 SSD 디스크 기반의 한 row 당 1KB 데이터 기준, 더 소요 될 수 있음.

책의 색인처럼 "정렬되어있는 기준을 알려준다"는 관점에서 중요하다.
- 정렬한 특정 데이터들을 기반으로 해당 데이터 목록 및 각 데이터의 원본 위치(포인터)를 저장한다.

> - 기본적으로 WHERE 조건(PK), JOIN 조건(외래키)에 사용하거나, 정렬에 많이 사용하는 대상을 인덱스에 넣어라.
> - 동등조건(유일성이 높거나 특정할 수 있는 항목)을 앞으로, 범위 조건은 뒤로 하며, 이는 인덱스 뿐만 아니라 쿼리에서도 적용하여 서로의 규칙을 일치하여 사용하도록 하자.
> - filesort를 피하기 위해 order by 조건과 일치하도록 인덱스 정렬에 적용하라.
> - 복합인덱스가 필요하다면 조건에 필요한 컬럼 순서대로 구성하라.

구체적인 내용은 별도 기술 
- [벨로그](https://velog.io/@gyrbs22/%EB%B0%B1%EC%97%94%EB%93%9C-Database-1-%EC%A0%95%EB%B3%B4%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%84-%EA%B3%A0%EB%AF%BC%ED%95%98%EB%8B%A4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81)
- 백로그(슬라이드)

## 9. 데이터 및 테이블 무결성을 위한 제약조건

시스템 신뢰도 및 장기적인 유지보수를 위해 안정적이고 명확한 데이터/테이블의 무결성 보장은 필수적이다.

- 데이터 유효성 > CONSTRAINT
- 데이터 내용의 유효성/세부적 규칙 > CHECK
- 테이블 간의 관계 무결성 > FK/PK

## 10. 트랜잭션

데이터를 변경하거나 다듬는 과정에서 논리적으로 분리할 수 없는 기능적 과정이자 단위
</br>

> 데이터베이스는 이러한 과정을 All or Nothing의 원칙으로, 하나의 동작이라도 실패하면 모든 데이터를 원점으로 되돌린다.
- 이러한 원자성을 데이터베이스 및 데이터의 일관성을 고려해야하는 중요 요인으로 간주할 수 있다.
- 이 외, 트랜잭션을 통해 데이터 및 데이터베이스의 일관성을 보장하는 중요 규칙이 바로 ACID 속성이다.
  - Atomic, 트랜잭션은 논리적으로 더이상 분리할 수 없으며 전무이거나, 전부이거나.
  - Consistency, 트랜잭션이 성공하거나 실패하거나, 그 과정은 항상 valid하며 데이터 혹은 데이터베이스의 일관성을 보장한다.
  - Isolation, 한 트랜잭션이 실행 중일때 다른 트랜잭션이 중간 결과에 끼어들 수 없다(=snapshot 유지 기간에 영향).
  - Durability, 트랜잭션이 성공하거나 실패하거나, 그 이후의 상태는 지속 유지된다.

## 11. 동시성

> MVCC
- 데이터베이스가 한 row에 대해 여러 버전을 관리하고 기록하면서, 다양한 요청에 대해 어떠한 버전의 row를 보여줄 것인가에 대한 설계적 원칙이자 전략이다.
- 최적화 기법, 성능적 차이가 미미하기에 Read Uncommitted는 대부분 선택하지 않는 전략이다(Read Committed 이상 제공).

구체적인 내용은 별도 기술
- 백로그(슬라이드)

참고사항 
- 현재 격리수준 확인 : SELECT @@transaction_isolation;
  - 만약 현재 세션(로컬)에서의 격리수준을 변경하고 싶다면 -> SET SESSION TRANSACTION ISOLATION LEVEL ~~~; 
- 인덱스 확인 : show index

## 12. 프리시저

비즈니스 로직 및 데이터베이스에 대한 질의와 DB의 연산을 분리하여 application이 질의에 따른 DB의 결과를 받는 상호작용이 아닌,
</br>
이러한 작업 자체를 모두 데이터베이스에 저장하는 체계가 프로시저이다.

- 저장 프로시저(SP, Stored Procedure)
  - 이름이 부여된 일련의 SQL 작업 묶음(CALL PROCEDURE)
- 저장 함수(SF, Stored Function)
  - 특정 계산을 수행하여 특정 값을 반드시 반환(Return)하는 프로그램
- 트리거(Trigger)
  - 특정 테이블의 특정 이벤트가 발생하였을때 자동으로 실행하도록 약속한 프로그램

이전 application의 성능이 좋지 않고, 네트워크 속도가 느릴때 사용하던 전략이었다.
- 애플리케이션을 통한 DB 질의 및 결과 반환보다, 저장 프로시저를 직접 호출하여 (네트워크를 줄이고) 빠른 연산을 진행하는 방법이 효율적인 전략이었다.
- 연산을 중앙관리화, 또한 외부 사용자에게 프로시저 권한을 부여하여 어느정도 안전한 데이터 관리 방안 수립이 가능하였다.

하지만 web MVC, 패턴구조가 다양해진 현대 시스템에서는 부적합한 요소가 너무 많아졌다.
- 비즈니스 규칙이 application과 프로시저 동시에 관리해야 하며, 이에 따른 유지보수 및 관리가 힘들다.
  - 비즈니스 로직의 책임이 시스템과 프로시저 모두에 있기에, 시스템을 이해하는데 시간이 오래 걸린다.
- 프로시저의 로그 및 버전관리를 DB에서 제공하지 않기에, 별도 문서화하는 등 버전관리가 매우 까다롭다.
- 또한 비즈니스 로직을 처리할때 시스템이 아닌 DB에 집중이 되어있기에, DB의 성능이 시스템 성능에 영향을 미치는 현상이 발생한다.
- 더불어 트래픽 규모가 커질 경우, WAS의 규모를 수평적으로 확장하면 비교적 단순한 개선이 가능하다.
  - 프로시저의 경우 DB자체의 성능을 개선하는 수직적 확장이 필요한데, 비용적으로 훨씬 소모되고 그 한계가 명확하다.
- 프로시저 자체가 DB종속적인 언어로, 데이터베이스 이전 시 언어 자체를 모두 종속DB에 맞게 변경해야 한다.

> 이러한 유지보수의 어려움 및 이에 대한 비용 절감을 위해 application과 DB 계층을 명확히 분리하였다.
- 서버는 비즈니스 로직 처리에 집중하고, DB는 데이터 관리 및 저장에 집중한다.
- 데이터 가공 및 처리는 서버에서, 데이터 저장 및 관리 등 본연의 역할을 철저하게 DB에서 책임지도록 그 영역을 분리한다.